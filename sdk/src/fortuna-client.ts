import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  Keypair,
  ConfirmOptions,
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
} from '@solana/spl-token';
import { Program, AnchorProvider, Idl, BN, Wallet } from '@coral-xyz/anchor';
import {
  ProtocolState,
  Market,
  Bet,
  License,
  CreateMarketConfig,
  InitializeProtocolConfig,
  IssueLicenseConfig,
  LicenseType,
  LicenseFeatures,
  MarketStatus,
  MarketStats,
  FeeBreakdown,
} from './types';
import {
  FORTUNA_PROGRAM_ID,
  TREASURY_WALLET,
  DEFAULT_PROTOCOL_FEE_BPS,
  DEFAULT_CREATOR_FEE_BPS,
  DEFAULT_POOL_FEE_BPS,
} from './constants';
import {
  getProtocolStatePDA,
  getMarketPDA,
  getMarketVaultPDA,
  getPoolVaultPDA,
  getBetPDA,
  getLicensePDA,
  calculateFees,
} from './utils';

// Import IDL type (generated by Anchor)
import type { FortunaProtocol } from './idl/fortuna_protocol';

/**
 * FortunaClient - High-level client for interacting with the Fortuna Protocol
 *
 * @example
 * ```typescript
 * const client = new FortunaClient(connection, wallet);
 *
 * // Initialize protocol
 * await client.initializeProtocol({
 *   treasury: treasuryWallet,
 *   protocolFeeBps: 50,   // 0.5%
 *   creatorFeeBps: 50,    // 0.5%
 *   poolFeeBps: 500,      // 5%
 * });
 *
 * // Create a market
 * const marketId = await client.createMarket({
 *   marketId: 1,
 *   title: "Will BTC reach $100k by end of 2024?",
 *   description: "Bitcoin price prediction market",
 *   betAmount: parseAmount("10", 6), // 10 USDC
 *   bettingDeadline: daysFromNow(7),
 *   resolutionDeadline: daysFromNow(30),
 *   outcomes: ["Yes", "No"],
 *   tokenMint: USDC_MINT,
 *   creatorFeeWallet: wallet.publicKey,
 * });
 *
 * // Place a bet
 * await client.placeBet(marketId, 0); // Bet on "Yes"
 * ```
 */
export class FortunaClient {
  private connection: Connection;
  private wallet: Wallet;
  private provider: AnchorProvider;
  private program: Program<FortunaProtocol> | null = null;
  private programId: PublicKey;

  constructor(
    connection: Connection,
    wallet: Wallet,
    programId: PublicKey = FORTUNA_PROGRAM_ID,
    opts?: ConfirmOptions
  ) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;
    this.provider = new AnchorProvider(
      connection,
      wallet,
      opts || { commitment: 'confirmed' }
    );
  }

  /**
   * Set the program IDL (required before making calls)
   */
  setProgram(idl: Idl): void {
    this.program = new Program(idl, this.programId, this.provider) as Program<FortunaProtocol>;
  }

  /**
   * Get the program instance
   */
  getProgram(): Program<FortunaProtocol> {
    if (!this.program) {
      throw new Error('Program not initialized. Call setProgram() with the IDL first.');
    }
    return this.program;
  }

  // ============================================================================
  // Protocol Management
  // ============================================================================

  /**
   * Initialize the protocol with fee settings
   */
  async initializeProtocol(config: InitializeProtocolConfig = {}): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);

    const tx = await program.methods
      .initializeProtocol(
        config.protocolFeeBps ?? DEFAULT_PROTOCOL_FEE_BPS,
        config.creatorFeeBps ?? DEFAULT_CREATOR_FEE_BPS,
        config.poolFeeBps ?? DEFAULT_POOL_FEE_BPS
      )
      .accounts({
        protocolState,
        authority: this.wallet.publicKey,
        treasury: config.treasury ?? TREASURY_WALLET,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Get protocol state
   */
  async getProtocolState(): Promise<ProtocolState | null> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);

    try {
      const state = await program.account.protocolState.fetch(protocolState);
      return state as unknown as ProtocolState;
    } catch {
      return null;
    }
  }

  /**
   * Update protocol settings
   */
  async updateProtocol(
    newTreasury?: PublicKey,
    newProtocolFeeBps?: number,
    newCreatorFeeBps?: number,
    newPoolFeeBps?: number
  ): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);

    const tx = await program.methods
      .updateProtocol(
        newTreasury ?? null,
        newProtocolFeeBps ?? null,
        newCreatorFeeBps ?? null,
        newPoolFeeBps ?? null
      )
      .accounts({
        protocolState,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  // ============================================================================
  // Market Management
  // ============================================================================

  /**
   * Create a new prediction market
   */
  async createMarket(config: CreateMarketConfig): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);

    const marketId = typeof config.marketId === 'number'
      ? new BN(config.marketId)
      : config.marketId;

    const [market] = getMarketPDA(marketId, this.programId);
    const [marketVault] = getMarketVaultPDA(market, this.programId);
    const [poolVault] = getPoolVaultPDA(market, this.programId);

    const tx = await program.methods
      .createMarket(
        marketId,
        config.title,
        config.description,
        typeof config.betAmount === 'number' ? new BN(config.betAmount) : config.betAmount,
        new BN(config.resolutionDeadline),
        new BN(config.bettingDeadline),
        config.outcomes
      )
      .accounts({
        protocolState,
        market,
        tokenMint: config.tokenMint,
        marketVault,
        poolVault,
        creator: this.wallet.publicKey,
        creatorFeeWallet: config.creatorFeeWallet,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market data by ID
   */
  async getMarket(marketId: BN | number): Promise<Market | null> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);

    try {
      const market = await program.account.market.fetch(marketPDA);
      return market as unknown as Market;
    } catch {
      return null;
    }
  }

  /**
   * Get market statistics
   */
  async getMarketStats(marketId: BN | number): Promise<MarketStats | null> {
    const market = await this.getMarket(marketId);
    if (!market) return null;

    const totalPool = market.totalPool;
    const outcomeStats = market.outcomes.map((outcome) => {
      const percentage = totalPool.isZero()
        ? 0
        : (outcome.totalAmount.toNumber() / totalPool.toNumber()) * 100;

      return {
        label: outcome.label,
        totalAmount: outcome.totalAmount,
        bettorCount: outcome.bettorCount,
        percentage,
      };
    });

    return {
      totalBettors: market.outcomes.reduce((sum, o) => sum + o.bettorCount, 0),
      totalPool,
      bonusPool: market.bonusPool,
      outcomeStats,
    };
  }

  /**
   * Get all markets (with optional filters)
   */
  async getAllMarkets(): Promise<Market[]> {
    const program = this.getProgram();
    const markets = await program.account.market.all();
    return markets.map((m) => m.account as unknown as Market);
  }

  /**
   * Get markets by status
   */
  async getMarketsByStatus(status: MarketStatus): Promise<Market[]> {
    const markets = await this.getAllMarkets();
    return markets.filter((m) => m.status === status);
  }

  // ============================================================================
  // Betting
  // ============================================================================

  /**
   * Place a bet on a market outcome
   */
  async placeBet(
    marketId: BN | number,
    outcomeIndex: number,
    bettorTokenAccount?: PublicKey
  ): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    const [marketVault] = getMarketVaultPDA(marketPDA, this.programId);
    const [poolVault] = getPoolVaultPDA(marketPDA, this.programId);
    const [betPDA] = getBetPDA(marketPDA, this.wallet.publicKey, this.programId);

    // Get market to find token mint
    const market = await this.getMarket(marketId);
    if (!market) throw new Error('Market not found');

    const protocol = await this.getProtocolState();
    if (!protocol) throw new Error('Protocol not initialized');

    // Get or derive token accounts
    const userTokenAccount = bettorTokenAccount || await getAssociatedTokenAddress(
      market.tokenMint,
      this.wallet.publicKey
    );

    const treasuryTokenAccount = await getAssociatedTokenAddress(
      market.tokenMint,
      protocol.treasury
    );

    const creatorTokenAccount = await getAssociatedTokenAddress(
      market.tokenMint,
      market.creatorFeeWallet
    );

    const tx = await program.methods
      .placeBet(outcomeIndex)
      .accounts({
        protocolState,
        market: marketPDA,
        bet: betPDA,
        marketVault,
        poolVault,
        bettorTokenAccount: userTokenAccount,
        treasuryTokenAccount,
        creatorTokenAccount,
        bettor: this.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Get bet data for a specific market and bettor
   */
  async getBet(marketId: BN | number, bettor?: PublicKey): Promise<Bet | null> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    const [betPDA] = getBetPDA(marketPDA, bettor || this.wallet.publicKey, this.programId);

    try {
      const bet = await program.account.bet.fetch(betPDA);
      return bet as unknown as Bet;
    } catch {
      return null;
    }
  }

  /**
   * Get all bets for a market
   */
  async getMarketBets(marketId: BN | number): Promise<Bet[]> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);

    const bets = await program.account.bet.all([
      {
        memcmp: {
          offset: 8, // After discriminator
          bytes: marketPDA.toBase58(),
        },
      },
    ]);

    return bets.map((b) => b.account as unknown as Bet);
  }

  // ============================================================================
  // Resolution & Claims
  // ============================================================================

  /**
   * Resolve a market (creator only)
   */
  async resolveMarket(marketId: BN | number, winningOutcome: number): Promise<string> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);

    const tx = await program.methods
      .resolveMarket(winningOutcome)
      .accounts({
        market: marketPDA,
        resolver: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings after market resolution
   */
  async claimWinnings(
    marketId: BN | number,
    claimerTokenAccount?: PublicKey
  ): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    const [marketVault] = getMarketVaultPDA(marketPDA, this.programId);
    const [betPDA] = getBetPDA(marketPDA, this.wallet.publicKey, this.programId);

    const market = await this.getMarket(marketId);
    if (!market) throw new Error('Market not found');

    const userTokenAccount = claimerTokenAccount || await getAssociatedTokenAddress(
      market.tokenMint,
      this.wallet.publicKey
    );

    const tx = await program.methods
      .claimWinnings()
      .accounts({
        protocolState,
        market: marketPDA,
        bet: betPDA,
        marketVault,
        claimerTokenAccount: userTokenAccount,
        claimer: this.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    return tx;
  }

  /**
   * Cancel a market (creator only)
   */
  async cancelMarket(marketId: BN | number): Promise<string> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);

    const tx = await program.methods
      .cancelMarket()
      .accounts({
        market: marketPDA,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim refund for cancelled market
   */
  async claimRefund(
    marketId: BN | number,
    claimerTokenAccount?: PublicKey
  ): Promise<string> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    const [marketVault] = getMarketVaultPDA(marketPDA, this.programId);
    const [betPDA] = getBetPDA(marketPDA, this.wallet.publicKey, this.programId);

    const market = await this.getMarket(marketId);
    if (!market) throw new Error('Market not found');

    const userTokenAccount = claimerTokenAccount || await getAssociatedTokenAddress(
      market.tokenMint,
      this.wallet.publicKey
    );

    const tx = await program.methods
      .claimRefund()
      .accounts({
        market: marketPDA,
        bet: betPDA,
        marketVault,
        claimerTokenAccount: userTokenAccount,
        claimer: this.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    return tx;
  }

  /**
   * Withdraw a bet before market resolution
   * Returns the stake minus fees (fees are non-refundable)
   */
  async withdrawBet(
    marketId: BN | number,
    bettorTokenAccount?: PublicKey
  ): Promise<string> {
    const program = this.getProgram();
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    const [marketVault] = getMarketVaultPDA(marketPDA, this.programId);
    const [betPDA] = getBetPDA(marketPDA, this.wallet.publicKey, this.programId);

    const market = await this.getMarket(marketId);
    if (!market) throw new Error('Market not found');

    const userTokenAccount = bettorTokenAccount || await getAssociatedTokenAddress(
      market.tokenMint,
      this.wallet.publicKey
    );

    const tx = await program.methods
      .withdrawBet()
      .accounts({
        market: marketPDA,
        bet: betPDA,
        marketVault,
        bettorTokenAccount: userTokenAccount,
        bettor: this.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    return tx;
  }

  // ============================================================================
  // Utility Methods
  // ============================================================================

  /**
   * Calculate fees for a bet amount
   */
  async calculateBetFees(betAmount: BN | number): Promise<FeeBreakdown> {
    const protocol = await this.getProtocolState();
    if (!protocol) throw new Error('Protocol not initialized');

    return calculateFees(
      betAmount,
      protocol.protocolFeeBps,
      protocol.creatorFeeBps,
      protocol.poolFeeBps
    );
  }

  /**
   * Get market PDA
   */
  getMarketPDA(marketId: BN | number): PublicKey {
    return getMarketPDA(marketId, this.programId)[0];
  }

  /**
   * Get bet PDA
   */
  getBetPDA(marketId: BN | number, bettor?: PublicKey): PublicKey {
    const [marketPDA] = getMarketPDA(marketId, this.programId);
    return getBetPDA(marketPDA, bettor || this.wallet.publicKey, this.programId)[0];
  }

  // ============================================================================
  // License Management
  // ============================================================================

  /**
   * Issue a new license
   */
  async issueLicense(config: IssueLicenseConfig): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [licensePDA] = getLicensePDA(config.licenseKey, this.programId);

    const tx = await program.methods
      .issueLicense(
        config.licenseKey,
        config.licenseType,
        config.allowedDomains ?? [],
        config.allowedWallets ?? [],
        config.maxMarkets ?? 0,
        config.isTransferable ?? true,
        new BN(config.expiresAt ?? 0)
      )
      .accounts({
        protocolState,
        license: licensePDA,
        holder: config.holder,
        authority: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Get license by key
   */
  async getLicense(licenseKey: number[]): Promise<License | null> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    try {
      const license = await program.account.license.fetch(licensePDA);
      return license as unknown as License;
    } catch {
      return null;
    }
  }

  /**
   * Get all licenses for a holder
   */
  async getLicensesByHolder(holder: PublicKey): Promise<License[]> {
    const program = this.getProgram();
    const licenses = await program.account.license.all([
      {
        memcmp: {
          offset: 8 + 32, // After discriminator + license_key
          bytes: holder.toBase58(),
        },
      },
    ]);
    return licenses.map((l) => l.account as unknown as License);
  }

  /**
   * Revoke a license (admin only)
   */
  async revokeLicense(licenseKey: number[]): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .revokeLicense()
      .accounts({
        protocolState,
        license: licensePDA,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Activate a license (admin only)
   */
  async activateLicense(licenseKey: number[]): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .activateLicense()
      .accounts({
        protocolState,
        license: licensePDA,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Transfer a license to a new holder
   */
  async transferLicense(licenseKey: number[], newHolder: PublicKey): Promise<string> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .transferLicense()
      .accounts({
        license: licensePDA,
        newHolder,
        currentHolder: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Update license settings (admin only)
   */
  async updateLicense(
    licenseKey: number[],
    newMaxMarkets?: number,
    newExpiresAt?: number,
    newFeatures?: LicenseFeatures
  ): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .updateLicense(
        newMaxMarkets ?? null,
        newExpiresAt !== undefined ? new BN(newExpiresAt) : null,
        newFeatures ?? null
      )
      .accounts({
        protocolState,
        license: licensePDA,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Add an authorized wallet to a license
   */
  async addAuthorizedWallet(licenseKey: number[], wallet: PublicKey): Promise<string> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .addAuthorizedWallet(wallet)
      .accounts({
        license: licensePDA,
        holder: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Remove an authorized wallet from a license
   */
  async removeAuthorizedWallet(licenseKey: number[], wallet: PublicKey): Promise<string> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .removeAuthorizedWallet(wallet)
      .accounts({
        license: licensePDA,
        holder: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Add an authorized domain to a license
   */
  async addAuthorizedDomain(licenseKey: number[], domain: string): Promise<string> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .addAuthorizedDomain(domain)
      .accounts({
        license: licensePDA,
        holder: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Remove an authorized domain from a license
   */
  async removeAuthorizedDomain(licenseKey: number[], domain: string): Promise<string> {
    const program = this.getProgram();
    const [licensePDA] = getLicensePDA(licenseKey, this.programId);

    const tx = await program.methods
      .removeAuthorizedDomain(domain)
      .accounts({
        license: licensePDA,
        holder: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Set whether license is required to create markets (admin only)
   */
  async setRequireLicense(requireLicense: boolean): Promise<string> {
    const program = this.getProgram();
    const [protocolState] = getProtocolStatePDA(this.programId);

    const tx = await program.methods
      .setRequireLicense(requireLicense)
      .accounts({
        protocolState,
        authority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get license PDA
   */
  getLicensePDA(licenseKey: number[]): PublicKey {
    return getLicensePDA(licenseKey, this.programId)[0];
  }
}
